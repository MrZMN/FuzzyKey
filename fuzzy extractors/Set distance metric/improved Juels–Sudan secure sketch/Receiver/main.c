#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <tgmath.h>
#include "solequations.h"
#include "lagrangeinterpolation.h"

#define setsize 10		//PS value set size s of fuzzy extractor 
#define errtolerant 4 	//error tolerance t of fuzzy extractor, which stands for symetric difference size (2 * num of sets mismatches), must be even number 
#define numerr 2
#define numcomb 45

void projectpoints(int size, int errnum, long double set[], long double points[][2], long double poly[]);
long double mulfortimes(long double num, int times);
void comb(int* arr, int start, int* result, int count, const int NUM, const int arr_len, long double* realarr, long double psvalues[][4], int* ctr);
void findmistake(int size, int num, long double* set, long double psvalues[][4]);

int main(){

	srand((unsigned)time(NULL));	//For random number generation
	register int i;
	long double errvals[numerr];	///for test only///
	int lasterr = -1;

	long double setB[setsize] = {3.059000, 7.847000, 9.666000, 9.268000, 6.992000, 7.155000, 6.616000, 9.498000, 7.876000, 7.014000};	//setB[] stores the PS values measured by the RX
	// add some errors in the measured PS values -- for test only --
    for(i = 0; i < numerr; i++){
    	int errloc = rand()%setsize;
    	if(i == 0){
    		lasterr = errloc;
    	}else{
    		while(errloc == lasterr){
    			errloc = rand()%setsize;
    		}
    	}	
    	printf("modified PS value: %Lf\n", setB[errloc] = rand()%10000/1000.0); 	
    	errvals[i] =  setB[errloc];
    }

	long double ss[errtolerant] = {-74.991000, 2514.048345, -49589.673059, 636900.638241}; //ss[] stores the secure sketch received from TX, used to construct phigh(x)
	long double points[setsize][2];                                                    //points[][2] stores the points generated by projecting setB values on phigh(x)
	long double Ab_matrix[setsize][setsize+1];                                         //Ab_matrix[][] stores the augmented matrix in B-W algorithm
	long double *Ab[setsize];                                                          //Ab is a pointer array - used to accelarate computation

	//evaluate the points by projecting setB values on phigh(x). The points are stored in points[][]
    projectpoints(setsize, errtolerant, setB, points, ss);

    //Use Reed-Soloman Decoding (Berlekamp-Welch algorithm) to generate a poly from 'setsize' num of points, succeed if at least (s-t/2) points are legit
    //generate the augmented matrix (size: setsize*(setsize+1))
    for(i = 0; i < setsize; i++){
    	Ab_matrix[i][0] = mulfortimes(points[i][0], 7);
    	Ab_matrix[i][1] = mulfortimes(points[i][0], 6);
    	Ab_matrix[i][2] = mulfortimes(points[i][0], 5);
    	Ab_matrix[i][3] = mulfortimes(points[i][0], 4);
    	Ab_matrix[i][4] = mulfortimes(points[i][0], 3);
    	Ab_matrix[i][5] = mulfortimes(points[i][0], 2);
    	Ab_matrix[i][6] = mulfortimes(points[i][0], 1);
    	Ab_matrix[i][7] = mulfortimes(points[i][0], 0);
    	Ab_matrix[i][8] = points[i][0]*points[i][1];
    	Ab_matrix[i][9] = -points[i][1];
    	Ab_matrix[i][10] = mulfortimes(points[i][0], 2)*points[i][1];
    }
    //convert the 2D augmented array into 1D pointer array format, to accelerate computation
	for(i=0;i<setsize;i++){
  		Ab[i] = Ab_matrix[i];
	}
	//Elementary row transformation to solve the solutions of equations
	guass_elimination(Ab, setsize, setsize+1);

    //find the wrong PS measurements
	long double psvalues[numcomb][4];	
	findmistake(setsize, 2, setB, psvalues);
	long double faultps1;
	long double faultps2; 
	long double min = 10000.0;
	for(i = 0; i < numcomb; i++){
		psvalues[i][3] = fabs((psvalues[i][3]*(*(Ab[setsize-2]+(setsize-2))) + psvalues[i][2]*(*(Ab[setsize-2]+(setsize-1)))) - *(Ab[setsize-2]+(setsize)));
		psvalues[i][2] = fabs(psvalues[i][2]*(*(Ab[setsize-1]+(setsize-1))) - *(Ab[setsize-1]+(setsize)));

		if(min > (psvalues[i][3] + psvalues[i][2])){
			faultps1 = psvalues[i][0];
			faultps2 = psvalues[i][1];
			min = psvalues[i][3] + psvalues[i][2];
		}
	}
	printf("These PS measurements got wrong: %Lf, %Lf\n", faultps1, faultps2);
	

    //get the legit points to reconstruct plow(x) -----this will cause precision loss------
	long double rightpoints[setsize-errtolerant][2];
	int ctr3 = 0;
	for(i = 0; i < setsize; i++){
		if((points[i][0]!=faultps1)&&(points[i][0]!=faultps2)&&(ctr3<(setsize-errtolerant))){
			rightpoints[ctr3][0] = points[i][0];
			rightpoints[ctr3][1] = points[i][1];
			// printf("%Lf, %Lf\n", rightpoints[ctr3][0], rightpoints[ctr3][1]);
			ctr3++;
		}
	}
	//Lagrange Interpolation 
    lagrange(rightpoints, setsize-errtolerant);

    printf("The key is:");
    for(i = 0; i < polydegree+1; i++){
        printf("%d ", (int)(fabs(key[i])+0.5));
    }
    printf("\n");

////Till now, we could do: 1. find out the wrong PS measurements at RX side, if the number of wrong measurements are within the error tolerance threshold. 
////2. For TX and RX, generate some common values (not strictly proved to be secure). Otherwise, RX could send the index of wrong values to TX to agree on their shared PS values. 
////The problem is: Because we use decimals representing the PS measurements~ it will cause precision loss, which makes we can't implement the last step proposed by the paper
////Maybe using GF() field instead of decimals could solve this - put it later   

}

//generate points on a poly (phigh(x) in the fuzzy extractor paper)
void projectpoints(int size, int errnum, long double set[], long double points[][2], long double poly[]){
	int i, j;
	for(i = 0; i < size; i++){
		points[i][0] = set[i];
		points[i][1] = mulfortimes(set[i], size);
		for(j = 0; j < errnum; j++){
			points[i][1] += poly[j]*mulfortimes(set[i], size-j-1);
		}
	}
}

//this function calculates the product of num*num*... for times time
long double mulfortimes(long double num, int times){
	if(times == 0){
		return 1.0;
	}else{
		int i;
		long double result = num;
		for(i = 1; i<times; i++){
			result = result * num;
		}
		return result;
	}
}

//this fuction does the relevant combination & product calculation 
//psvalues[][4]: 1st and 2nd cols store the two ps value pairs; 3rd col stores the product value; 4th col stores the addition value 
void comb(int* arr, int start, int* result, int count, const int NUM, const int arr_len, long double* realarr, long double psvalues[][4], int* ctr)
{
    int i = 0;
    for (i = start; i < arr_len + 1 - count; i++)
    {
        result[count - 1] = i;
        if (count - 1 == 0)
        {
            int j;
            long double product = 1.0;
            long double add = 0.0;
            int ctr2 = 0;
            for (j = NUM - 1; j >= 0; j--){
                product *= realarr[arr[result[j]]];
                add += realarr[arr[result[j]]];
                psvalues[*ctr][ctr2] = realarr[arr[result[j]]];
                ctr2 += 1;
            }

           	psvalues[*ctr][2] = product;
           	psvalues[*ctr][3] = add;
            *ctr += 1;
        }else
            comb(arr, i + 1, result, count - 1, NUM, arr_len, realarr, psvalues, ctr);
    }
}

//this function calculates the secure sketch values
void findmistake(int size, int num, long double* set, long double psvalues[][4]){

    int i;
    int arr[size];
    for(i = 0; i < size; i++){
        arr[i] = i;
    }
    int result[num];
    int val = 0;
    int* valpointer = &val;

    comb(arr, 0, result, num, num, sizeof(arr)/sizeof(int), set, psvalues, valpointer);
}

